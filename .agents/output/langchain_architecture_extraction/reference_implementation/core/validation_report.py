"""
Validation reporting for LLM-generated outputs.

ValidationReport provides structured accumulation of validation results,
typically used when validating code or structured data generated by LLMs.
"""
from dataclasses import dataclass
from typing import Any, Callable, Dict, List


@dataclass
class ValidationReport:
    """
    Structured report accumulating validation results.

    Used to track validation progress across multiple stages (e.g., syntax → loading → execution).
    Provides dual logging: both to standard logger and to accumulated report entries.

    Attributes:
        input: The input that was validated (for context)
        output: Dictionary containing validation-specific data (e.g., parsed results)
        report_entries: List of human-readable log entries accumulated during validation
        passed: Overall validation result (True = all stages passed)

    Usage pattern:
        report = ValidationReport(input=code, output={}, report_entries=[], passed=False)
        try:
            # Stage 1: Syntax validation
            report.append_entry("Checking syntax...", logger.info)
            validate_syntax(code)
            report.append_entry("Syntax valid", logger.info)

            # Stage 2: Semantic validation
            report.append_entry("Checking semantics...", logger.info)
            validate_semantics(code)
            report.append_entry("Semantics valid", logger.info)

            report.passed = True
        except ValidationError as e:
            report.append_entry(f"Validation failed: {e}", logger.error)
            report.passed = False
    """
    input: str
    output: Dict[str, Any]
    report_entries: List[str]
    passed: bool

    def to_json(self) -> Dict[str, Any]:
        """Serialize ValidationReport for persistence or transmission."""
        return {
            "input": self.input,
            "output": self.output if self.output else None,
            "report_entries": self.report_entries if self.report_entries else None,
            "passed": self.passed
        }

    @classmethod
    def from_json(cls, json_data: Dict[str, Any]) -> 'ValidationReport':
        """Deserialize ValidationReport from JSON."""
        return cls(
            input=json_data['input'],
            output=json_data.get('output', {}),
            report_entries=json_data.get('report_entries', []),
            passed=json_data.get('passed', False)
        )

    def append_entry(self, entry: str, logging_function: Callable[..., None]):
        """
        Append a validation log entry.

        This method provides dual logging:
        1. Logs to standard logger via logging_function (e.g., logger.info)
        2. Appends to report_entries for structured accumulation

        Args:
            entry: Human-readable log message
            logging_function: Logger method to use (logger.info, logger.warning, logger.error, etc.)

        Example:
            report.append_entry("Syntax check passed", logger.info)
            report.append_entry("Missing required field", logger.warning)
        """
        logging_function(entry)
        self.report_entries.append(entry)
