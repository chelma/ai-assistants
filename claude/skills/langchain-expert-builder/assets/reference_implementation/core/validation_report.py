"""
Validation reporting for LLM-generated outputs.

ValidationReport provides structured accumulation of validation results,
typically used when validating code or structured data generated by LLMs.

DESIGN PHILOSOPHY:

ValidationReport serves three critical purposes in the multi-expert architecture:

1. Human debugging: Detailed report entries show exactly where/why LLM output failed,
   enabling developers to diagnose prompt issues, adjust schemas, or improve examples.

2. LLM self-correction: Feed ValidationReport back to the same expert in a multi-turn
   conversation to enable automatic retry with structured feedback (e.g., "Validation
   failed: Missing required field 'timestamp'. Please revise.").

3. Model tuning observability: ValidationReport + Task context = complete training example.
   - Input: Task.context (system prompt + user message)
   - Output: Task work item (LLM's structured response)
   - Label: ValidationReport.passed + report_entries (diagnostic details)
   - Use case: Collect (prompt, response, validation) tuples across production for fine-tuning
   - Benefit: Improve baseline success rate for specific expert tasks

WHY STRUCTURED REPORTS:
- Programmatic access to pass/fail status (report.passed)
- Detailed diagnostic entries for understanding failure modes
- Serializable format for logging, persistence, or transmission to LLM
- Dual logging (logger + report entries) for both real-time and post-hoc analysis
"""
from dataclasses import dataclass
from typing import Any, Callable, Dict, List


@dataclass
class ValidationReport:
    """
    Structured report accumulating validation results.

    Used to track validation progress across multiple stages (e.g., syntax → loading → execution).
    Provides dual logging: both to standard logger and to accumulated report entries.

    Attributes:
        input: The input that was validated (for context)
        output: Dictionary containing validation-specific data (e.g., parsed results)
        report_entries: List of human-readable log entries accumulated during validation
        passed: Overall validation result (True = all stages passed)

    Usage pattern:
        report = ValidationReport(input=code, output={}, report_entries=[], passed=False)
        try:
            # Stage 1: Syntax validation
            report.append_entry("Checking syntax...", logger.info)
            validate_syntax(code)
            report.append_entry("Syntax valid", logger.info)

            # Stage 2: Semantic validation
            report.append_entry("Checking semantics...", logger.info)
            validate_semantics(code)
            report.append_entry("Semantics valid", logger.info)

            report.passed = True
        except ValidationError as e:
            report.append_entry(f"Validation failed: {e}", logger.error)
            report.passed = False
    """
    input: str
    output: Dict[str, Any]
    report_entries: List[str]
    passed: bool

    def to_json(self) -> Dict[str, Any]:
        """Serialize ValidationReport for persistence or transmission."""
        return {
            "input": self.input,
            "output": self.output if self.output else None,
            "report_entries": self.report_entries if self.report_entries else None,
            "passed": self.passed
        }

    @classmethod
    def from_json(cls, json_data: Dict[str, Any]) -> 'ValidationReport':
        """Deserialize ValidationReport from JSON."""
        return cls(
            input=json_data['input'],
            output=json_data.get('output', {}),
            report_entries=json_data.get('report_entries', []),
            passed=json_data.get('passed', False)
        )

    def append_entry(self, entry: str, logging_function: Callable[..., None]):
        """
        Append a validation log entry.

        This method provides dual logging:
        1. Logs to standard logger via logging_function (e.g., logger.info)
        2. Appends to report_entries for structured accumulation

        Args:
            entry: Human-readable log message
            logging_function: Logger method to use (logger.info, logger.warning, logger.error, etc.)

        Example:
            report.append_entry("Syntax check passed", logger.info)
            report.append_entry("Missing required field", logger.warning)
        """
        logging_function(entry)
        self.report_entries.append(entry)
